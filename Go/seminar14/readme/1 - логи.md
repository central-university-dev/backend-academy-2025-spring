# Логи

## Введение

**Логами** будем называть журнал значимых событий или значимой информации при работе приложения. Предполагается, что каждая такая запись в журнале имеет временную отметку (когда это событие записано), хотя это не строго обязательное требование.

Одно событие будем называть **строкой** логов/лога, чтобы не было путаницы со всем журналом.

**Формат** логов — это способ представления одной строки (события) в виде последовательности байт. Чаще всего, логи пишутся или в непосредственно текстовом формате, или в форматах, производных от текста, например, json.

**Formatter** — компонент приложения (например, класс), который форматирует логи. **Handler** — компонент приложения, который записывает отформатированную последовательность байт в конкретный вывод, например, в файл, stdout или stderr. 

В разных пакетах терминология может различаться, например, Handler может называться Writer.

## Логи приложений на golang

Логи приложения можно писать и в виде просто текста, собирая по частям строку с нужно информацией, например:

```go
log.Info(fmt.Sprintf("customer id %d has received order id %d", customer.id, order.id))
```

Этот подход не очень хорошо работает, когда надо анализировать логи большого количества экземпляров приложений. В облачной инфраструктуре логи приложений часто экспортируют в общее хранилище, поэтому важно, чтобы логи были структурированы. Обычно используется json формат логов.

### log/slog

Элементарный [пример](../code/app01/slog01/main.go).

Можно подключить дополнительный пакет `github.com/veqryn/slog-context` и передавать логгер с привязанными параметрами через контекст. [Пример](../code/app01/slog02).

### zap

Элементарный [пример с zap](../code/app01/zap/main.go).

### zerolog

Пакет `github.com/rs/zerolog` обладает такой же функциональностью. Пример из их документации:

```go
package main

import (
    "github.com/rs/zerolog"
    "github.com/rs/zerolog/log"
)

func main() {
    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix

    log.Debug().
        Str("Scale", "833 cents").
        Float64("Interval", 833.09).
        Msg("Fibonacci is everywhere")
    
    log.Debug().
        Str("Name", "Tom").
        Send()
}

// Output: {"level":"debug","Scale":"833 cents","Interval":833.09,"time":1562212768,"message":"Fibonacci is everywhere"}
// Output: {"level":"debug","Name":"Tom","time":1562212768}
```

## Логи приложений в docker и k8s

Если приложение разрабатывается для запуска в облачной инфраструктуре (k8s), то предпочтительно выводить логи именно в stdout/stderr, а не в файл. Основная причина этого в том, что жизненный цикл контейнера совпадает с жизненным циклом приложения, и при аварийном завершении приложения, экспортер логов может не успеть отправить последние логи в хранилище.

Жизненным циклом stdout/stderr управляет сторона, вызывающая приложение (а не само приложение). Например, можно посмотреть stdout остановленного контейнера.

При запуске приложения в docker-compose, можно для удобства перенаправить отдельные логи в файл. Например, можно избавиться от очень подробных логов кафки из примера [seminar08](../../seminar08/docker-compose.yaml). Добавим следующий код к 2 образам:

```yaml
  command: ["bash", "-c", "/etc/confluent/docker/run >/log/stdout.log 2>/log/stderr.log"]
  volumes:
    - ./containers-output/kafka1:/log
```

Благодаря строчке с command, вывод приложения будет перенаправлен из консоли в файлы. Благодаря строчке с volumes, эти файлы будут доступны с локальной машины, даже когда контейнер остановлен.

## Централизованное хранение логов

Есть смысл отправлять логи разных контейнеров в общее хранилище, где они будут доступны для анализа. Желающие могут воспользоваться популярным [шаблоном для ELK](https://github.com/deviantony/docker-elk). В нём есть простой docker-compose файл, который позволяет поднять весь стек для хранения логов (elasticsearch, logstash, kibana).

Этот стек можно использовать вместе с вашими приложениями. Как это сделать, написано в [их документации](https://github.com/deviantony/docker-elk/wiki/External-applications).

## Дополнительные материалы

Статья [Things that go wrong with disk IO](https://notes.eatonphil.com/2025-03-27-things-that-go-wrong-with-disk-io.html). Она написана в большей степени применительно к БД, но многие тезисы оттуда актуальны и для логов, которые пишут на диск. Рекомендуется прочитать.
