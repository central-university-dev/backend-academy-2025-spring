# Введение

## Терминология

**Кэш** — промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. Доступ к данным в кэше осуществляется быстрее, чем выборка исходных данных из более медленной памяти или удалённого источника, однако её объём существенно ограничен по сравнению с хранилищем исходных данных.

Это определение взято из [статьи на вики](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88). Полезно почитать эту статью, чтобы узнать о том, что кэш бывает аппаратный и программный, и о типичных примерах использования.

На этом занятии будут рассматриваться программные (а не аппаратные) подходы к кэшированию. Во всех примерах подразумевается, что есть основной источник данны (БД или другая внешняя система). Кэш является дополнительным источником данных. Скорость доступа к данным в кэше выше, чем к данным в основном источнике (иначе зачем всё это), но **ёмкость кэша ограничена**.

## Диаграммы

Некоторые диаграммы представлены в виде кода likeC4. У отдельных IDE могут быть проблемы с отображением диаграмм и с валидацией кода. В этом случае, используйте [playground.likec4.dev](https://playground.likec4.dev/) для отображения файлов `*.c4`.

Рассмотрим, каким образом кэш может располагаться относительно приложения (встраиваемый и выделенный): [диаграмма](../diagrams/01/examples.c4).

## Общие особенности

Создание и использование кэша в приложении — обычно понятная задача, сопоставимая по сложности с использованием основного источника данных:

* Создать и настроить экземпляр выделенного кэша плюс-минус так же сложно, как и создать и настроить экземпляр основной БД. 
* Запросы к данным в кэше и к данным основного хранилища обычно реализуются в виде абстракций одинакового уровня (репозиторий). 
* Организовать хранение и доступ к данным в памяти самого приложения ещё проще. 

Однако, поддержка и использование кэша сопровождается несколькими типичными проблемами.

### Деньги

Если используется кэширование, то это подразумевает, что:

1. Данные хранятся *избыточно*: помимо основного источника данных, данные хранятся в одном или нескольких экземплярах кэша.
2. Для избыточного хранения используется один из самых дорогих ресурсов: оперативная память.

Если приложение нужно масштабировать, то это приводит или может приводить к необходимости отмасштабировать и кэш:

* если используется in-app кэш, то количество экземпляров кэша равно количеству экземпляров приложения
* если используется внешний кэш, то на практике один экземпляр такого кэша всё равно может обслуживать ограниченное количество экземпляров приложения; на практике зависимость всё равно O(N)

**Если кэш можно вообще не использовать, то лучше так и сделать.** Это не значит, что никогда нельзя использовать кэш, но для использования кэширования должны быть причины. 

### Низкая надёжность

Надёжность кэша в смысле сохранности данных и изменений ниже, чем у основного хранилища.

**Пример 1**. Если используется in-app кэширование, и происходит отказ экземпляра приложения, то кэш этого экземпляра будет полностью потерян. Новый экземпляр будет запущен без этих данных, с пустым кэшем.

**Пример 2**. Если используется sidecar кэширование, то данные в экземпляре кэша сохраняются при отказе приложения. Но экземпляр кэша сам может отказать, и это будет означать потерю данных для множества экземпляров приложения.

**Пример 3**. В redis/valkey/keydb поддерживается операция `BGSAVE`. В ходе этой операции выполняется сохранение снапшота (слепка) данных ноды на диск, и эти данные могут быть использованы при отказе ноды для восстановления. Но это периодическая операция, и восстановленные данные будут устаревшими (актуальными на момент снятия слепка). Это значит, что все изменения, которые произошли в кэше с этого момента, будут потеряны.

**Пример 4**. В redis/valkey/keydb, кроме `BGSAVE`, можно настроить:
1. Инкрементальный логический журнал (AOF, append-only-file). 
2. Репликацию данных на другую ноду.

И в том, и в другом случае изменения в кэше копируются в резервный источник (в AOF или на реплику). Проблема состоит в том, что скорость записи в файл (AOF) или по сети (репликация) значительно ниже, чем скорость записи в оперативную память. Поэтому, изменения всё равно зеркалируются не непрерывно, а с заданной периодичностью (по умолчанию, 1 секунда). И даже в этом случае, последние изменения в случае отказа ноды всё равно будут потеряны.

Низкая надёжность является неизбежной платой за высокую скорость ответа. При проектировании приложения с кэшем, следует учитывать эти особенности. 

### Ограниченный объём

Необходимо ограничивать объём RAM, который может потреблять один экземпляр кэша. Причины этого:

* Деньги (см. выше). 
* Облачная инфраструктура накладывает ограничения на всё ПО, которое в ней запускается, включая экземпляры приложений и экземпляры кэша. Объём потребляемой памяти для каждого приложения ограничен, и нет гарантий, что будет возможность его изменить без перезапуска; это же относится и к экземплярам кэша.

Ограничение объёма рождает вопрос: что делать, если выделенного объёма памяти не хватает? 

**Во-первых**, экземпляр кэша может отказаться принимать это и дальнейшее изменения, то есть, стать read only. На практике, редко используется, потому что требует ручного вмешательства, если экземпляр перешёл в RO.

**Во-вторых**, экземпляр может использовать стратегию вытеснения ключей (key eviction). О том, какие стратегии используются в redis, можно почитать в [их документации](https://redis.io/docs/latest/develop/reference/eviction/). Общий смысл всех стратегий: отбросить *какие-то* ключи перед тем, как принять новые изменения. Пожалуй, наиболее универсальная стратегия — LRU (least recently used). 

Вытеснение ключей — ещё одна причина низкой надёжности: даже если экземпляр кэша не откажет, данные в нём всё равно могут быть потеряны.

### Инвалидация

Данные в основном хранилище меняются, и это может приводить к тому, что данные в кэше теряют актуальность. Возникает задача инвалидации данных в кэше — нужно удалить либо обновить неактуальные данные.

Есть разные подходы к инвалидации, которые будут рассмотрены позднее, но не существует абсолютно надёжного способа атомарно инвалидировать данные:

* Если используется внешний кэш, то приложение работает с двумя источниками данных, каждый из которых может отказать, вне зависимости от другого; то есть, может возникнуть ошибка при попытке удаления из кэша, при успешном обновлении данных в основном источнике, и наоборот.
* При использовании внешнего кэша, даже успешно принятые инвалидирующие изменения могут быть утеряны (см. [низкая надёжность](#низкая-надёжность)).
* Если использовать внутренний кэш, то можно положиться на то, что изменения в кэше не будут потеряны, но возникает необходимость донести изменения в основном источнике до каждого экземпляра приложения.
* Даже если все экземпляры кэша будут надёжным образом инвалидированы, всё равно останется окно несогласованности, в которое изменения уже зафиксированы в основном источнике, но ещё не инвалидированы во всех экземплярах кэша.

Не нужно стремиться к тому, чтобы гарантировать инвалидацию данных кэша; вместо этого, нужно проектировать приложения таким образом, чтобы влияние неактуальности данных было ограничено. Примеры:

1. Если требования позволяют использовать устаревшие данные, можно ограничивать время жизни данных (TTL). Это может выглядеть как дисклеймер "данные обновлялись 10 мин. назад". Через заданное время, данные автоматически удалятся из кэша (если не будут до этого обновлены), и системе придётся запросить их снова.
2. Система согласована в конечном счёте. В таком случае, в какой-то момент времени система может стать рассогласованной (из-за использования неактуальных данных кэша), но её механизмы неизбежно приведут к тому, что данные будут обновлены, и система обработает новое состояние.
