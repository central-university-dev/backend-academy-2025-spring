- [Стратегии доступа к данным](#стратегии-доступа-к-данным)
  - [Cache through](#cache-through)
  - [Cache ahead](#cache-ahead)

# Стратегии доступа к данным

## Cache through

Такая стратегия предполагает, что запросы на чтение и на изменение данных чётко разделены.

Приложению нужен контроль за изменением данных, чтобы поддерживать кэш в актуальном состоянии.

Основное хранилище представляет собой первую точку отказа. Выделенный кэш — вторую (можно сделать разумное допущение, что in-app кэш работает всегда, когда работает приложение).

### Happy path

```mermaid
zenuml
    title Чтение данных (read through)
    
    @Actor client
    app
    @Database cache
    @Database main as "main storage"
    
    client -> app : запрос на получение данных
    app -> cache : запрашивает кэш
    @return cache -> app : результат операции
    
    if ("попадание в кэш") {
        @return app -> client : возвращает данные из кэша
    } else if ("промах мимо кэша") {
        app -> main : запрашивает основное хранилище
        @return main -> app : данные из основного хранилища
        
        app -> cache : обновляет кэш
        @return cache -> app : кэш успешно обновлён
        
        @return app -> client : возвращает данные
    }
```

```mermaid
zenuml
    title Изменение данных (write through)
    
    @Actor client
    app
    @Database cache
    @Database main as "main storage"
    
    client -> app : запрос на изменение данных
    
    app -> main : обновляет данные в основном хранилище
    @return main -> app : хранилище успешно обновлено
    
    app -> cache : обновляет данные в кэше
    @return cache -> app : кэш успешно обновлён
    
    app -> client : результат операции
```

### Проблемы

Недоступность кэша при запросе на чтение данных:

```mermaid
zenuml
    title Чтение данных (read through)
    
    @Actor client
    app
    @Database cache
    @Database main as "main storage"
    
    client -> app : запрос на получение данных
    app -> cache : запрашивает кэш
    
    @return cache -> app : ошибка запроса
    @return app -> client : ошибка запроса
```

Недоступность кэша при запросе на изменение данных:

```mermaid
zenuml
    title Изменение данных (write through)
    
    @Actor client
    app
    @Database cache
    @Database main as "main storage"
    
    client -> app : запрос на изменение данных
    
    app -> main : обновляет данные в основном хранилище
    @return main -> app : хранилище успешно обновлено
    
    app -> cache : обновляет данные в кэше
    @return cache -> app : не получилось обновить кэш
    
    app -> client : результат операции
```

## Cache ahead

Эта стратегия подходит только для запросов **на чтение**. Приложение запрашивает только кэш при обслуживании этих запросов. 

Также организуется отдельный периодический процесс, который обновляет данные в кэше, загружая туда данные из основного хранилища.

При использовании этой стратегии заранее предполагается, что запрашиваемые данные не будут актуальными.

### Happy path

```mermaid
zenuml
    title Cache ahead
    
    @Actor client
    app
    @Database cache
    @Database main as "main storage"
    
    opt {
        client -> app : запрос на получение данных
        app -> cache : запрашивает кэш
        @return cache -> app : результат операции
        
        if ("попадание в кэш") {
            @return app -> client : данные из кэша
        } else if ("промах мимо кэша") {
            @return app -> client : данные не найдены
        }
    }
    
    while ("периодически") {
        app -> main : запрашивает основное хранилище
        @return main -> app : данные из основного хранилища
        
        app -> cache : обновляет кэш
        @return cache -> app : кэш успешно обновлён
    }
```

### Проблемы

Недоступность кэша при запросе на чтение данных:

```mermaid
zenuml
    title Cache ahead
    
    @Actor client
    app
    @Database cache
    
    client -> app : запрос на получение данных
    app -> cache : запрашивает кэш
    @return cache -> app : кэш недоступен
    @return app -> client : ошибка запроса
```

В случае, если при синхронизации кэша с основным хранилищем недоступен либо кэш, либо хранилище, приложение продолжит отдавать последние актуальные данные.
